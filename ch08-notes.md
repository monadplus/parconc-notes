# Chapter 8. Overlapping Input/Output

_GetURL.hs_: small wrapper around the API provided by the HTTP package

_geturls1.hs_: use forkIO and MVar to download two web pages at the same time.

The code is quite verbose, we want to extract the common pattern as a new abstraction.

We want a way to perform an action _asynchronoussly_ and later wait for its result.

```haskell
data Async a = Async (MVar a)

async :: IO a -> IO (Async a)
async action = do
  var <- newEmptyMVar
  forkIO (do r <- action; putMVar var r)
  return (Async var)

wait :: Async a -> IO a
wait (Async var) = readMVar var -- read instead of take: allow multiple calls to wait for it.
```

_geturls2.hs_: cleaner version


_geturls3.hs_: prints amount of time spend in the progress.

### Exceptions in Haskell

Haskel 98 and 2010 standards provide a limited form of exceptions:

- the _IO Exception_

The module _Control.Exception_ that comes with GHC includes exceptions generated by purely functional code:

- _error_
- pattern-matching failure
- Extensible hierarchy of exception types.

> Haskell has no special syntax or built-in semantics for exception handling; everything is done with library functions.

`throw :: Exception e => e -> a`

Exception type class is provided by _Control.Exception_:

```haskell
class (Typeable e, Show e) => Exception e where
  -- ...
```

Any type that extends Typeable and Show can be an _Exception_.

One common type used as exception is:

```haskell
newtype ErrorCall = ErrorCall String deriving (Typeable)

instance Show ErrorCall where { ... }
instance Exception ErrorCall
```

> Ennable automatic derivation of _Typeable_, we need to turn on the _-XDeriveDataTypeable_ flag.

Example: `throw (ErrorCall "oops!")`

In fact, the function _error_ defined in Prelude does exactly this.

```haskell
error :: String -> a
error s = throw (ErrorCall s)
```

I/O operations in Haskell throw exception to indicate errors, and these are usually
values of the _IOException_ type.

Exceptions in Haskell can be caught, __but only in the IO monad__:

`catch :: Exception e => IO a -> (e -> IO a) -> IO a`: catches only exceptions of a particular type.


Catching any exception ?
Exceptions forms a hierarchy, and at the top of the hierarchy is a type called _SomeException_
that includes all exceptions type.

```haskell
>>> throw (ErrorCall "oops") `catch` \e -> print ( e :: SomeException )
```

Useful for:

- Testing and debugging.
- Performing some cleanup, before rethrowing the exception.

- `try :: Exception e => IO a -> IO (Either e a)`

Handle: catch with argument reversed:

- `handle :: Exception e => (e -> IO a) -> IO a -> IO a`

It is useful for situation like this:

```haskell
handle (\e -> ...) $ do
  ...
```

Perform some operation if an exception is raised and then rethrow the error:

`onException :: IO a -> IO b -> IO a`

> It is always better to use throwIO rather than throw in the IO monad because throwIO guarantees strict ordering with respect to other IO operations, whereas throw does not.

`throwIO :: Exception e => e -> IO a`

Exception handler to reliably deallocate a resource or perform some cleanup operation (also supports thread cancellation):

`bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c`

For example:

```haskell
bracket (newTempFile "temp")
          (\file -> removeFile file)
          (\file -> ...)
```

`finally :: IO a -> IO b -> IO a`: special case of bracket

### Error Handling with Async

_forkIO_ has a default exception handler. The default exception handler prints the error to the _stderr_ and then terminates the thread.

If the net is down, _geturls2.hs_ will throw an exception on async and then will deadlock in _wait_.

_geturls4.hs_: Async that supports error handling.

```haskell
data Async a = Async (MVar (Either SomeException a)) -- <1>

async :: IO a -> IO (Async a)
async action = do
  var <- newEmptyMVar
  forkIO (do r <- try action; putMVar var r)  -- <2>
  return (Async var)

waitCatch :: Async a -> IO (Either SomeException a) -- <3>
waitCatch (Async var) = readMVar var

wait :: Async a -> IO a -- <4>
wait a = do
  r <- waitCatch a
  case r of
    Left e  -> throwIO e
    Right a -> return a
```

#### Merging

Example code at _geturls5.hs_ (single MVar, all threads try to write, only the first one will be able to do so). The
idea is good but __there are better approaches__.

Better approach: Await for either two Async simultaneously, returning the result of the first one to succeed or
propagating the exception if either Async fails (code at _geturls6.hs_).

```haskell
waitEither :: Async a -> Async b -> Async (Either a b)
waitEither a b = do
  m <- newEmptyMVar
	forkIO $ do r <- try (fmap Left  (wait a)); putMVar m r
	forkIO $ do r <- try (fmap Right (wait b)); putMVar m r
	wait (Async m)
```

The first one two finish will put it's result into the MVar. The second one will wait until it is read (You could actually read it twice, but the API doesn't allow it).

> Notice we need to create two new threads to collect the results of each Async and merge them into a new MVar.

We can generalize _waitEither_ to wait for a list of Asyncs, returning the result from the first one to complete:

```haskell
waitAny :: [Async a] -> IO a
waitAny as = do
  m <- newEmptyMVar
  let forkwait a = forkIO $ do r <- try (wait a); putMVar m r
  mapM_ forkwait as
	wait (Async m)
```

Example at _geturls6.hs_.

> STM allows a neater and more efficient implementation of _waitAny_.
